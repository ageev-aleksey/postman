\documentclass[a4paper,12pt]{report}
%\documentclass[twoside]{article}
\input{header.tex}

\title{SMTP сервер\textnumero 1}
\author{(Агеев~А.~В.)}

\begin{document}
	\maketitle

	\tableofcontents

	\addcontentsline{toc}{chapter}{Введение}
	\chapter*{Введение}
	Для функционирования компьютерных сетей, на оборудовании устанавливается программное обеспечение реализующий различные протоколы взаимодействия. Протоколы различаются по назначению. В данное время для обеспечения сети интернет используется стек протоколов TCP/IP, который состоит из протоколов выполняющий каждый свою задачу:
	\begin{itemize}
		\item Канальный уровень (например Ethernet)~--~беспечивают отправку и прием данных данных через среду передачи.
		\item Сетевой уровень (ip)~--~Канальный уровень работает с множеством устройств, которые объединены в одну группу (сеть). В данной группе устройства <<видят>> друг друга напрямую. Протоколы сетевого уровня предназанчены для обеспечения взаимодействия устройст из разных групп. Две сети объединяются маршрутизатором, а с помощью протокола сетевого уровня выплняется адресация устройст. В этом случае, между устройствами разных групп существует посредник -- маршрутизатор
		\item Транспортный уровень (TCP, UDP) -- на современном оборудовании работает множество программ, для определения того, какой программе адресованы прешедшые данные из сети, используются протоклы транспротного уровня. Их основная цель -- адресация процессов на устройстве.
		\item Прикладной уровень -- данные протоколы реализуются приложениями, которую выполняют некоторую задачу. 
	\end{itemize}

	Целью курсовой работы является реализация протокола прикладоного уровня для получения и доставки электронной почты -- Simple Mail Transfer Protocol (SMTP). А именно, части, которая выполняет прием почты и выполняет ее передачу на следующий этап -- отправку почты. 
	
	Вариант 1 предпологает многопоточную реализацию сервера.

	\chapter{Аналитический раздел}
	\section{Основные понятия протокола SMTP}

	 SMTP протокол основан на клиент-серверной архитектуре. В данном случае клиентом выступает программа, которая хочет отправить почту, а сервером является программа для приема почты. Протокол поддреживает маршрутизацию почты, то есть серверу может придти письмо, которое адресовано клиенту на другом сервере. В этом случае серверное программное обеспечение принимает роль клиента и отправлет почту другому серверу. 

	 Протокол состоит из текстовых сообщений, которые передают друг другу клиент и сервер при взаимодействии. Каждое сообщение прдеставляет из себя команду с параметрами, которые выполняются сервером. На какждую команду серверв выдает отклик. При организации надежного соединения (например посредством протокола TCP) клиент инициирует почтову транзакцию, которая состоит из последовательности команд, задающих отправителя и получателя сообщения, а так же передается содержательная часть письма. После чего клиент может завершить сеанс или начать новую почтовую транзакцию для передачи очередного письма.

	 \underline{Объекты электронной почты:} (\{Конверт; Содержимое\})
	 \begin{itemize}
	 	\item Конверт
	 	   \begin{itemize}
	 	       \item Адрес отправителя -- определяется командой \textit{MAIL FROM}, которая так же начинает почтовую транзакцию. 
	 	       \item Адрес получателей - с помощью команды \textit{RCPT TO} определяется один получатель и маршрут почты до этого получателя (в RFC2821 указано, что лучше механизм маршрутизации почты игнорировать). Данная команда может быть передана несоклько раз для указания списка получателей одного письма.
	 	       \item Дополнительные заголовки. Протокол SMTP поддреживает расширения - добавление новых заголовков и параметров к стандартным заголовкам.
	 	   \end{itemize}
	 	  \item Содержимое -- передается после отправки команды \textit{DATA}
	 	  \begin{itemize}
	 	      \item Заголовок - список полей вида <ключ>:<значение>, спецификация которых описана в RFC5322
	 	      \item Тело сообщения - это непосредственное содержимое письма, которая представляет из себя текстовый набор данных соответсвущий спецификации форматов разны типов объектов MIME (Multipurpose Internet Mail Extensions)
	 	  \end{itemize}
	 \end{itemize}
	 Все элементы описваются с исопльзованием 7-битной кодировки US-ASCII, но это ограничение может быть снято с использованием расширения протокола \textit{8BITMIE}
	
	 \underline{Получатель и отправитель:}
	 
	 Протокол SMTP работает в 2 стороны. Получателем и отправителем может выступать как почтовая служба на сервере так и клиентское программное обеспечение. В протоколе выделяются следующие понятия:
	 \begin{itemize}
	     \item Клиент -- Отправлющая сторона в текущей почтовой транзакции.
	     \item Сервер -- Принимающая сторона в текущей почтовой транзации.
	     \item Агент доставки почты (Mail Transfer Agent, MTA)~-- Клиент и сервер SMTP обеспечивающее почтовый трансопртный сервис.
	     \item Пользовательский почтовый агент (Mail User Agent, MUA)~-- Программное обеспечение выступающее в качетсве исходных отправителей и конечных получателей почтовых сообщений
	 \end{itemize}
	 $$MUA\rightarrow MTA \rightarrow MTA \rightarrow MUA$$
	 
	 \underline{Типы агентов SMTP:}
	 
	 \begin{itemize}
	     \item Система отрпавки (originator) -- Вносит сообщение в среду передачи данных, в котором находится транспортный сервис.
	     \item Система доставки (delivery) -- Принимает почту от транспортного серивса и передает ее пользовательскому агенту или размещает ее в хранилище.
	     \item Транслятор (relay) -- Получает почту от клиента и передает ее другому серверу.
	     \item Шлюз (gateway) -- Система получающие письма от одной транспортной среды и передающие письма сереверу находящейся в другой транспортной среде.
	 \end{itemize}
	 
	 
	 \section{SMTP сеанс}
	 
	 При подключении клиента к серверу начинается SMTP сеанс, в течении которого выполняется взаимодействие клиента и сервера по доставки писем.
	 \begin{enumerate}
	     \item Инициирование соединения 
	     
	     Клиент: создает соединение с сервером
	     
	     Сервер: Отправляет отклик
	     \begin{itemize}
	         \item 220 в случае готовности
	         \item 554 в случае отказа в SMTP сервисе
	     \end{itemize}
	     \item Инициирование клиента (сеанса)
	     
	     Клиент: передает команду \textit{HELO/EHLO}. \textit{HELO} - содание SMTP сеанса. \textit{EHLO} - создание SMTP сеанса с поддержкой расширений протокола (Extend Hello).
	     
	     Сревер: Отрпавляет отклик 250. Если бла отправлена команда \textit{EHLO}, то сервер так же возращает список расширений, который он поддерживает (расширения далее не рассматриваются)
	     
	     \item Почтовая транзакция (Транзакцию нельзя сделать вложеной в другую транзакцию)
	     \begin{enumerate}
	         \item \label{item:mail_transaction} Начало транзакции
	         
	         Клиент: Отправлет команду \textit{MAIL FROM}. Команда говорит о запуске новой почтовой транзакции и передает адрес отправителя. Если в процессе передачи возникнет ошибка, на этот адрес будет отправлено уведомление.
	         
	         Сервер: Отклик 250
	         
	         \item Определение спика получателей
	         
	         Для определение списка получателей клиент отправлет несколько команд \textit{RCPT TO}, на каждую из которых сервер отправляет отклик 250.
	         
	         Если команда \textit{RCPT TO} отправлена до начала почтовой транзакции, то сервер отправлет отклик 503
	         
	         \item Передача тела письма 
	         
	         Клиент: Отправлет команду \textit{DATA} 
	         
	         Сервер: отправлет отклик 354, что свидетельствует о том, что сервер готов принимать содержимое письма
	         
	         Клиент: Отрпавлет все почтовые данные. После завершения отправки тела письма, клиент должен отправить точку на отдельной строке (<CRLF>.<CRLF>~--~послеовательность кончания данных письма)
	         
	         Сервер: Должен воспринимать все присилаемые данные, как тело письма. Как только он получает последовательность конца данных (<CRLF>.<CRLF>) сервер должен инициировать процесс доставки письма. А клиенту отправить отклик 250
	     \end{enumerate}
	     
	     \item Завершение сеанса или новая транзакция
	     \begin{itemize}
	         \item Если клиент желает завершить работу с сервером, то он должен послеть команду \textit{QUIT}, на которую сервер должен ответить откликом 221 и закрыть соединение.
	         \item Если клиент желает продолжить работу с сервером, то он должен создать новую почтовую транзакцию. Для этого необходимо перейти на шаг \ref{item:mail_transaction}
	     \end{itemize}
	 \end{enumerate}
	 
	 \underline{Дополнительные команды:}
	 \begin{enumerate}
	     \item \textit{VRFY}
	     \item \textit{EXPN}
	     \item \textit{RSET} -- прерывание текущей почтовой транзакции. Отклик сервера: 250
	     \item \textit{HELP}
	     \item \textit{NOOP}
	 \end{enumerate}
	
	 \section{Синтаксис команд}\label{section:smtp_syntax}
	 \begin{verbatim}
ehlo = "EHLO" SP Domain CRLF
helo = "HELO" SP Domain CRLF
ehlo-ok-rsp  = ("250" domain [SP ehlo-greet] CRLF)
              | ("250-" domain [SP ehlo-greet] CRLF
              | *("250-" ehlo-line CRLF)
              | ("250" SP ehlo-line CRLF)

ehlo-greet = 1*(%d0-9 / %d11-12 / %d14-127)
ehlo-line = ehlo-keyword *( SP ehlo-param )
ehlo-keyword = (ALPHA / DIGIT) *(ALPHA / DIGIT / "-")
ehlo-param   = 1*(%d33-127)
"MAIL FROM:" ("<>" / Reverse-Path) [SP Mail-parameters] CRLF
"RCPT TO:" ("<Postmaster@" domain ">" /
           "<Postmaster>" / Forward-Path) 
           [SP Rcpt-parameters] CRLF
"DATA" CRLF
"RSET" CRLF
"VRFY" SP String CRLF
"EXPN" SP String CRLF
"HELP" [ SP String ] CRLF
"NOOP" [ SP String ] CRLF
"QUIT" CRLF
Reverse-path = Path
Forward-path = Path
Path = "<" [ A-d-l ":" ] Mailbox ">"
A-d-l = At-domain *( "," A-d-l )
At-domain = "@" domain
Mail-parameters = esmtp-param *(SP esmtp-param)
Rcpt-parameters = esmtp-param *(SP esmtp-param)
esmtp-param     = esmtp-keyword ["=" esmtp-value]
esmtp-keyword   = (ALPHA / DIGIT) *(ALPHA / DIGIT / "-")
esmtp-value     = 1*(%d33-60 / %d62-127)
Keyword  = Ldh-str
Argument = Atom
Domain = (sub-domain 1*("." sub-domain)) / address-literal
sub-domain = Let-dig [Ldh-str]
address-literal = "[" IPv4-address-literal / 
                      IPv6-address-literal /
                      General-address-literal "]"
Mailbox         = Local-part "@" Domain
Local-part      = Dot-string / Quoted-string
Dot-string      = Atom *("." Atom)
Atom            = 1*atext
Quoted-string   = DQUOTE *qcontent DQUOTE
String          = Atom / Quoted-string
IPv4-address-literal    = Snum 3("." Snum)
IPv6-address-literal    = "IPv6:" IPv6-addr
General-address-literal = Standardized-tag ":" 1*dcontent
Standardized-tag        = Ldh-str
Snum                    = 1*3DIGIT
Let-dig                 = ALPHA / DIGIT
Ldh-str                 = *( ALPHA / DIGIT / "-" ) Let-dig
IPv6-addr               = IPv6-full / IPv6-comp / IPv6v4-full / IPv6v4-comp
IPv6-hex  = 1*4HEXDIG
IPv6-full = IPv6-hex 7(":" IPv6-hex)
IPv6-comp = [IPv6-hex *5(":" IPv6-hex)] "::" [IPv6-hex *5(":"IPv6-hex)]
IPv6v4-full = IPv6-hex 5(":" IPv6-hex) ":" IPv4-address-literal
IPv6v4-comp = [IPv6-hex *3(":" IPv6-hex)] "::"
              [IPv6-hex *3(":" IPv6-hex) ":"] IPv4-address-literal

	 \end{verbatim}
	 	\chapter{Конструкторский раздел}
	     \section{Структура программы}

    Для реализации поддержки многопоточности используется Циклы событий, смысл которого заключается в том, что существует бесконечный цикл, ожидающий событий на сокете через системный вызов poll. Данный цикл работает в отдельном потоке. Так же существует несколько других потоков, которые называются работниками. Они выполняют обработку возникающих событий. Сущесвует следующее множество событий, для которых можно назначить функцию обработчик:
    \begin{enumerate}
        \item Событие <<Подключился клиент>>
        \item Событие <<Выполнено чтение из сокета>>
        \item Событие <<Выполнена запись в сокет>>
        \item Событие <<Истек таймер>>
    \end{enumerate}
    
    Основным преймуществом данного подхода заключается в том, что все потоки разделают одно адресное пространство -- быстрое взаимодействие между ними. В отличие от многопроцессной архитектуры, в которой имеются накладные расходы на обмен информацией между процессами, так необходимо использоватеь соответсвующие системные вызовы, что заставлет процессор переключаться в режим ядра. Хотя постоянное использование механизмов синхронизации, при доступе к разделяемым ресурсам, так же замедляет работу приложения. А недостатком многопотончой архитектуры является ненадежность -- если в одном из потоке произойдет критическая ошика (например \textit{SIGFAULT}), то будет уничтожен процесс, соответсвенно все потоки приложения немедленно завершат свою работу. В этом случае многопроцессная архитектура имеет преймущество в виде надежности. Критическая ошибка в одном процессе не затрагивает другие процессы. Так же можно реализовать отдельный процесс, который будет выполнять мониторинг состояний рабочих процессов (watchdog-процесс), и вслучае экстренного завершения одного из процессов, watchdog-процесс должен будет выполнить восстановление завершившегося процесса (выполнение его повторного запуска). 
    
    Менеджер событий реализуется посредством струтуры \textit{event\_loop}, запускаемый функцией \textit{el\_open} в отдельном потоке. Структуре сопутсвуют функции для регистрации обработчиков на события. Регистрация на событие одноразовое, т.е. после вызова обработчика события, данный обработчик не будет реагировать на данное событие -- его необходимо заново зарегистрировать. 
    
    Рабочим потокам, которые будут обрабатывать события, необхоимо в цилке вызывать функцию \textit{el\_run}, функция выполняет обработку одного события и завершает работу. Если в момент вызова, отсутсвовали какие либо события, то функция немедленно возращает управление, сообщая об отсутсвии событий в возращаемом статусе. Пример работы цикла событий показан на диаграмме последовательности (рис. \ref{appendix:event_loop}). 

Функция \textit{el\_run} только обрабатывает событие, не предполагает создание потока. Для реализации многопоточной обработки был реализована вспомогательная структура \textit{thread\_pool}, используюя функции которой создаются потоки. Внутри каждого потока в бесконечном цикле выполняется вызов функции \textit{el\_run}. 
    

    
    Для корректного завершения работы, бесконечные циклы, на самом деле проверяют условие <<Необходиом ли дальше работать>> (циклы логически бесконечны, так как они работают до тех пор, пока работает приложение). Для корректного заврешния работы программы, используется обработчик сигналов, который регистрируется в операционной системе. Если приходит сигнал \textit{SIGTERM} или \textit{SIGINT}, то обработчик вызывает функцию \textit{el\_stop}, которая изменяет флаг работы цикла событий с true на false. Таким образом на очередной проверки условия работы цикла всеми потоками, учавствующие в цикле событий, будет произведен выход. Все потоки завершат свою работу и приложение остановится.
    
    \begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./include/smtp_fsm.pdf}
	\caption{Конечный автомат протокола SMTP}
	\label{fig:smtp_fsm}
\end{figure}

    
    Обработка сеанса протокола SMTP выполняется на основе цикла событий. Для реализации конечного автомата и связанных с ним действий была реализована стркуктура \textit{smtp\_state}, которая содержит в себе конечный автомат, созданный посредством утилиты \textit{autofsm}. На рисунке \ref{fig:smtp_fsm} показан конечный автомат, который описан в файле \textit{smtp-states.def}. Овалами обозначены состояния, а метки ребер это команды. Таким образом каждая команда выполняет изменение состояния. Существует ряд меток, которые как команды, отсутсвуют в протоколе. 
    \begin{itemize}
        \item \textit{TEST} -- это метка обозначает следующие команды: \textit{VRFY}; \textit{EXPN}; \textit{HELP} \textit{NOOP}; 
        \item \textit{READ} -- это любая последовтаельность символов кроме \textit{.\textbackslash{}r\textbackslash{}n} (точка на отдельной строке).
    \end{itemize}
    
    \underline{Состояния конечного автомата (рис. \ref{fig:smtp_fsm})}
    \begin{enumerate}
        \item init -- Начальное состояние, в котором находится соединение, когда клиент только подлкючился к серверу
        \item client init -- Состояние инициализированного smtp сеанса. В него выполняется переход после отправки команды \textit{HELO} или \textit{EHLO}
        \item begin transaction -- инициализация почтовой транзакции, которая происходит, когда клиент отправлет команду \textit{MAIL FROM}
        \item transaction -- определение списка получателей, с помощью команды \textit{RCPT TO}
        \item  read data -- получение сервером тела письма. Данная стадия запускается командой \textit{DATA} и продолжается до тех пор, пока не будет получена последовательность конца данных (точка на отдельной строке: \textit{.\textbackslash{}r \textbackslash{}n}). На рисунке обозначена меткой END
        \item done -- завершение сенаса клиента с сервреом. Отправлется команда \textit{QUIT} и сервер закрывает соединение с клиентом.
    \end{enumerate}
    
    Автомат описывает только корректную последовательность команд, но если в некотором состоянии будет передана команда, которая не определена конечным автоматом, то состояние не изменится, а сервер сформирует отклик с кодом 503, означающий что клиент ввел неподходяющую команду (некорректная последовательность команд).
    
    Для обработки команд SMTP протокола, синтаксис которых описан в разедел \ref{section:smtp_syntax}, исполльзовались регулярные выражения, которые входят в поставку вместе с компилятором языка С. Регулярные выражения описаны в следующем листинге:
    \input{./include/regex}
    
    Для хранения почты, получаемой сервером посрдеством почтовой транзакции, используется файловая система. Используемая струтктура каталогов взята из спецификации \textit{MAILDIR}, которая описана в [???]. Формат maildir имеет следующую структуру каталогов:
    \begin{verbatim}
        - maildir_root
        |
        |- user_path
        |    |- cur
        |    |- tmp
        |    |- new
        |
        |- user2_path
        |    |- cur
        |    |- tmp
        |    |- new
    \end{verbatim}
    Где maildir\_root - кореньевая папка. user\_path, user2\_path - каталоги пользователей текущей почтовой службы. cur, tmp, new - папки содержащие письма. 
    new - сюда попадают письма новые письма, которые пользователь не прочитал. cur - письма просмотренные пользователем. tmp - пиьсма находящиеся на стадии доставки, необходимость этой папки заключается в том, что запись данных в файл не является атомарной операцией. Если этой папки не будет то при создании файла, например в папке new, может произойти так, что программа для чтения локальной почты, попытается открыть этот новый файл, а программа доставки почты еще не успела туда записать данные. По этому используется каталог tmp для исключения таких случаев. Пока данные записываются в файл, тот находится в папке tmp, как только письмо полностью записано в файл, то программа доставки писем перенсит этот файл в каталог new.
    
    При создании новых файлов писем, им необходимо даватб имена. Для создания уникального имени формат MAILDIR трактует слудющие правила:
    \begin{verbatim}
        <pid><sender_mailbox><timestamp><random_value>
    \end{verbatim}
    Где <pid> - идентификатор процесса, выполняющий доставку почты; <sender\_mailbox> - адрес электронной почты отправителя письма;  <timestamp> - время UNIX; <random\_value> - случайное целое число.
    
    Поскольку формат MAILDIR разработан для доставки локальной почты, а по заданию необходимо обрабатывать и глобальную почту (почту адресованную пользователям на других серверах), то формат MAILDIR был модифицирован следующим образом: 
        
        \begin{verbatim}
        - maildir_root
        |
        |- user_path
        |    |- cur
        |    |- tmp
        |    |- new
        |
        |- user2_path
        |    |- cur
        |    |- tmp
        |    |- new
        |
        |- .OTHER_SERVERS
        |    |- tmp
        |    |- new
    \end{verbatim}
    Модификация maildir добавляет папку \textit{.OTHER\_SERVERS}, в которой слкадываются все письма, приходящие на данный сервер, но адресованные пользователям других почтовых служб. папки \textit{.OTHER\_SERVERS/tmp} и  \textit{.OTHER\_SERVERS/new} имеют теже самые назначения, что и папки для пользователей. Папка \textit{.OTHER\_SERVERS/cur} отсутствует, так как после того как письма из папки \textit{.OTHER\_SERVERS/new} будет доставлено другому серверу будет удалена. Так же изменен формат создания уникального имени файла:
    \begin{verbatim}
        <timestamp>_<random_value>
    \end{verbatim}
    Использую такой формат, нельзя определить по файлу от кого письмо и кому адресовано, по этому при записи письма в \textit{.OTHER\_SERVERS} к телу письма дописываются дополнительные заголовик, с помощью которых отправляющая программа сможет определить адресата и адресанта:
    \begin{verbatim}
        X-Postman-From: <mailbox>
        X-Postman-Date: <timestamp>
        X-Postman-To: <mailbox> [, <mailbox> [...]]
        <пустая строка (\r\n)>
        <тело письма полученное во время почтовой транзакции>
    \end{verbatim}
    
    Обработка данной структуры в файловой системы реаизовано с помощью класса \textit{maildir}. Дописыване дополнительных заголовков реализовано в обработчике почтовой транзакции, а не внутри класса \textit{maildir}.

\section{Основные функции программы}

Данный паздел создан с помощью программы doxygen

\input{./include/doxygen/event_loop.h.tex}
\input{./include/doxygen/smtp_state.h.tex}
\input{./include/doxygen/smtp_state.h.tex}   
\input{./include/doxygen/maildir.h.tex}
\input{./include/doxygen/maildir_server.h.tex}
\input{./include/doxygen/maildir_user.h.tex}
\input{./include/doxygen/maildir_user.h.tex}
	\section{Тестирование}
		Для тестирования функциональности сервера, было написаны unit-тесты
		с использованием библиотеки cunit. Резултат работы тестиованяи представлен
		в листинге 
		\VerbatimInput{./include/unit_test_out.tex}
		\VerbatimInput{./include/valgrind_out.tex}
		
		Так же было выполнено системное тестирование
		отчет по покрытию тестами представлен в следующей таблице
		%\begin{landscape}
		%	\input{./include/lcov/index}
		%\end{landscape}
		Отчет по покрытию тестами не строится в  gitlab!

	
	\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{./include/cflow.pdf}
	\caption{Граф вызовов в модуле EventLoop}
	\label{fig:event}
	\end{figure}

	\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{./include/make.pdf}
	\caption{Структура проекта}
	\label{fig:make_server}
	\end{figure}

	Для реализации smtp протокола использовались регулярные выражения. Которые представленны в следующем листинге
	

	\section{Список источников и литературы}
	\begin{enumerate}
		\item http://rfc.com.ru/rfc2821.htm
		\item http://rfc.com.ru/rfc1123
		\item https://www.protocols.ru/WP/rfc5322/
		\item RFC 1035 DOMAIN NAMES — IMPLEMENTATION AND SPECIFICATION  https://www.protocols.ru/WP/rfc1035/
		\item dovecot maildir https://wiki.dovecot.org/MailLocation/Maildir
		\item qmail maildir https://cr.yp.to/proto/maildir.html
	\end{enumerate}
	
	\newpage
	%\appendix
	%\section{A}\label{appendix:event_loop}
	% \begin{figure}[H]
    %\centering
  %\includegraphics[scale=01]{./resource/SequenceDiagram_EventLoop.pdf}
%\end{figure}
 % Диграмма последовательности цикла событий сервера, описывающая подключение клиента, который отправлет запрос, ожидает ответ, а потом отключается. При отключении клиента, выставлется соответсвующий флаг, который обрабатывается в обработчике чтения из сокета или записи в сокет.
\end{document}